diff --git a/mbed-client-pal/Source/Port/Reference-Impl/Lib_Specific/mbedTLS/Crypto/pal_plat_Crypto.c b/mbed-client-pal/Source/Port/Reference-Impl/Lib_Specific/mbedTLS/Crypto/pal_plat_Crypto.c
index 7379290..3035f4e 100755
--- a/mbed-client-pal/Source/Port/Reference-Impl/Lib_Specific/mbedTLS/Crypto/pal_plat_Crypto.c
+++ b/mbed-client-pal/Source/Port/Reference-Impl/Lib_Specific/mbedTLS/Crypto/pal_plat_Crypto.c
@@ -291,13 +291,23 @@ PAL_PRIVATE palStatus_t pal_plat_x509CertGetID(palX509Ctx_t* x509Cert, uint8_t *
 {
     palStatus_t status = PAL_SUCCESS;
     int32_t platStatus = CRYPTO_PLAT_SUCCESS;
+    int mbedtlsStatus = 0;
+    mbedtls_pk_context *x509Cert_pk = NULL;
 
-    platStatus = mbedtls_ecp_point_write_binary( &((mbedtls_ecp_keypair *)((x509Cert->crt).pk).pk_ctx)->grp, &((mbedtls_ecp_keypair *)((x509Cert->crt).pk).pk_ctx)->Q,
+    mbedtlsStatus = mbedtls_x509_crt_pk_acquire(&x509Cert->crt, &x509Cert_pk);
+    if (mbedtlsStatus != 0) {
+        status = PAL_ERR_FAILED_TO_WRITE_PUBLIC_KEY;
+        mbedtls_x509_crt_pk_release(&x509Cert->crt);
+        return status;
+    }
+
+    platStatus = mbedtls_ecp_point_write_binary( &((mbedtls_ecp_keypair *)x509Cert_pk->pk_ctx)->grp, &((mbedtls_ecp_keypair *)x509Cert_pk->pk_ctx)->Q,
          MBEDTLS_ECP_PF_COMPRESSED, actualOutLenBytes, id, outLenBytes);
     if (platStatus != CRYPTO_PLAT_SUCCESS)
     {
         status = PAL_ERR_FAILED_TO_WRITE_PUBLIC_KEY;
     }
+    mbedtls_x509_crt_pk_release(&x509Cert->crt);
     return status;
 }
 
@@ -307,7 +317,12 @@ PAL_PRIVATE palStatus_t pal_plat_X509GetField(palX509Ctx_t* x509Ctx, const char*
     int32_t platStatus = CRYPTO_PLAT_SUCCESS;
     const char *shortName = NULL;
     size_t fieldNameLength = 0;
-    mbedtls_x509_name *x509Name = &x509Ctx->crt.subject;
+    int ret = 0;
+
+    mbedtls_x509_name *x509Name = NULL;
+    ret = mbedtls_x509_crt_get_subject(&x509Ctx->crt, &x509Name);
+    if (ret != 0)
+        return ret;
 
     fieldNameLength = strlen(fieldName);
     while( x509Name ) 
@@ -333,6 +348,7 @@ PAL_PRIVATE palStatus_t pal_plat_X509GetField(palX509Ctx_t* x509Ctx, const char*
         }
         x509Name = x509Name->next;
     }
+    mbedtls_x509_name_free(x509Name);
     return status;
 }
 
@@ -397,33 +413,39 @@ PAL_PRIVATE palStatus_t pal_timegm( struct tm *tm, uint64_t* outTime)
 palStatus_t pal_plat_x509CertGetAttribute(palX509Handle_t x509Cert, palX509Attr_t attr, void* output, size_t outLenBytes, size_t* actualOutLenBytes)
 {
     palStatus_t status = PAL_SUCCESS;
-    palX509Ctx_t* localCtx = (palX509Ctx_t*)x509Cert;
     *actualOutLenBytes = 0;
+    int ret = 0;
+
+    palX509Ctx_t* localCtx = (palX509Ctx_t*)x509Cert;
+    mbedtls_x509_crt_frame const *frame;
+    ret = mbedtls_x509_crt_frame_acquire(&localCtx->crt, &frame);
+    if (ret != 0)
+        return ret;
 
     switch(attr)
     {
         case PAL_X509_ISSUER_ATTR:
-            if (localCtx->crt.issuer_raw.len <= outLenBytes)
+            if (frame->issuer_raw.len <= outLenBytes)
             {
-                memcpy(output, localCtx->crt.issuer_raw.p, localCtx->crt.issuer_raw.len);
+                memcpy(output, frame->issuer_raw.p, frame->issuer_raw.len);
             }
             else
             {
                 status = PAL_ERR_BUFFER_TOO_SMALL;
             }
-            *actualOutLenBytes = localCtx->crt.issuer_raw.len;
+            *actualOutLenBytes = frame->issuer_raw.len;
             break;
 
         case PAL_X509_SUBJECT_ATTR:
-            if (localCtx->crt.subject_raw.len <= outLenBytes)
+            if (frame->subject_raw.len <= outLenBytes)
             {
-                memcpy(output, localCtx->crt.subject_raw.p, localCtx->crt.subject_raw.len);
+                memcpy(output, frame->subject_raw.p, frame->subject_raw.len);
             }
             else
             {
                 status = PAL_ERR_BUFFER_TOO_SMALL;
             }
-            *actualOutLenBytes = localCtx->crt.subject_raw.len;
+            *actualOutLenBytes = frame->subject_raw.len;
             break;
 
         case PAL_X509_VALID_FROM:
@@ -435,12 +457,12 @@ palStatus_t pal_plat_x509CertGetAttribute(palX509Handle_t x509Cert, palX509Attr_
             {
                 struct tm time;
                 uint64_t timeOfDay;
-                time.tm_year = localCtx->crt.valid_from.year;
-                time.tm_mon = localCtx->crt.valid_from.mon;
-                time.tm_mday = localCtx->crt.valid_from.day;
-                time.tm_hour = localCtx->crt.valid_from.hour;
-                time.tm_min = localCtx->crt.valid_from.min;
-                time.tm_sec = localCtx->crt.valid_from.sec;
+                time.tm_year = frame->valid_from.year;
+                time.tm_mon = frame->valid_from.mon;
+                time.tm_mday = frame->valid_from.day;
+                time.tm_hour = frame->valid_from.hour;
+                time.tm_min = frame->valid_from.min;
+                time.tm_sec = frame->valid_from.sec;
                 time.tm_isdst = -1;                                   //unknown DST 
                 status = pal_timegm(&time, &timeOfDay);
                 if (PAL_SUCCESS != status)
@@ -464,12 +486,12 @@ palStatus_t pal_plat_x509CertGetAttribute(palX509Handle_t x509Cert, palX509Attr_
             {
                 struct tm time;
                 uint64_t timeOfDay;
-                time.tm_year = localCtx->crt.valid_to.year;
-                time.tm_mon = localCtx->crt.valid_to.mon;
-                time.tm_mday = localCtx->crt.valid_to.day;
-                time.tm_hour = localCtx->crt.valid_to.hour;
-                time.tm_min = localCtx->crt.valid_to.min;
-                time.tm_sec = localCtx->crt.valid_to.sec;
+                time.tm_year = frame->valid_to.year;
+                time.tm_mon = frame->valid_to.mon;
+                time.tm_mday = frame->valid_to.day;
+                time.tm_hour = frame->valid_to.hour;
+                time.tm_min = frame->valid_to.min;
+                time.tm_sec = frame->valid_to.sec;
                 time.tm_isdst = -1;                                 //unknown DST
                 status = pal_timegm(&time, &timeOfDay);
                 if (PAL_SUCCESS != status)
@@ -509,18 +531,19 @@ palStatus_t pal_plat_x509CertGetAttribute(palX509Handle_t x509Cert, palX509Attr_
             break;
 
         case PAL_X509_SIGNATUR_ATTR:
-            if (localCtx->crt.sig.len > outLenBytes) {
+            if (frame->sig.len > outLenBytes) {
                 status = PAL_ERR_BUFFER_TOO_SMALL;
                 break;
             }
 
-            memcpy(output, localCtx->crt.sig.p, localCtx->crt.sig.len);
-            *actualOutLenBytes = localCtx->crt.sig.len;
+            memcpy(output, frame->sig.p, frame->sig.len);
+            *actualOutLenBytes = frame->sig.len;
             break;
 
         default:
            status = PAL_ERR_INVALID_X509_ATTR;
     }
+    mbedtls_x509_crt_frame_release(&localCtx->crt);
     return status;
 }
 
@@ -893,6 +916,8 @@ palStatus_t pal_plat_verifySignature(palX509Handle_t x509, palMDType_t mdType, c
     int32_t platStatus = CRYPTO_PLAT_SUCCESS;
     mbedtls_md_type_t mdAlg = MBEDTLS_MD_NONE;
     palX509Ctx_t* localCtx = (palX509Ctx_t*)x509;
+    mbedtls_pk_context *pk;
+    int ret;
 
     switch (mdType)
     {
@@ -904,7 +929,11 @@ palStatus_t pal_plat_verifySignature(palX509Handle_t x509, palMDType_t mdType, c
             goto finish;
     }
 
-    platStatus = mbedtls_pk_verify(&localCtx->crt.pk, mdAlg, hash, hashLen, sig, sigLen);
+    ret = mbedtls_x509_crt_pk_acquire( &localCtx->crt, &pk );
+    if (ret != 0)
+        return ret;
+
+    platStatus = mbedtls_pk_verify(pk, mdAlg, hash, hashLen, sig, sigLen);
     if (platStatus == CRYPTO_PLAT_SUCCESS) {
         status = PAL_SUCCESS;
     }
@@ -918,6 +947,7 @@ palStatus_t pal_plat_verifySignature(palX509Handle_t x509, palMDType_t mdType, c
         status = PAL_ERR_PK_SIG_VERIFY_FAILED;
     }
 finish:
+    mbedtls_x509_crt_pk_release( &localCtx->crt );
     return status;
 }
 #endif 
@@ -2287,6 +2317,8 @@ palStatus_t pal_plat_x509CertGetHTBS(palX509Handle_t x509Cert, palMDType_t hash_
 {
     palStatus_t status = PAL_SUCCESS;
     palX509Ctx_t *crt_ctx = (palX509Ctx_t*)x509Cert;
+    mbedtls_x509_crt_frame const *frame;
+    int ret = 0;
 
     switch (hash_type) {
         case PAL_SHA256:
@@ -2294,8 +2326,16 @@ palStatus_t pal_plat_x509CertGetHTBS(palX509Handle_t x509Cert, palMDType_t hash_
                 status = PAL_ERR_BUFFER_TOO_SMALL;
                 break;
             }
-            status = pal_plat_sha256(crt_ctx->crt.tbs.p, crt_ctx->crt.tbs.len, output);
+
+            ret = mbedtls_x509_crt_frame_acquire(&crt_ctx->crt, &frame);
+            if (ret != 0) {
+                status = ret;
+                break;
+            }
+
+            status = pal_plat_sha256(frame->tbs.p, frame->tbs.len, output);
             *actualOutLenBytes = PAL_SHA256_SIZE;
+            mbedtls_x509_crt_frame_release(&crt_ctx->crt);
             break;
         default:
             status = PAL_ERR_INVALID_MD_TYPE;
@@ -2393,6 +2433,8 @@ palStatus_t pal_plat_x509CSRFromCertWriteDER(palX509Handle_t x509Cert, palx509CS
 {
     palX509Ctx_t *localCert = (palX509Ctx_t*)x509Cert;
     palx509CSR_t *localCSR = (palx509CSR_t*)x509CSR;
+    mbedtls_x509_crt_frame const *frame;
+    mbedtls_x509_name *x509Name = NULL;
     char subject[512];
     int mbedtls_ret;
 
@@ -2402,7 +2444,11 @@ palStatus_t pal_plat_x509CSRFromCertWriteDER(palX509Handle_t x509Cert, palx509CS
 
     // subject
 
-    mbedtls_ret = mbedtls_x509_dn_gets(subject, sizeof(subject), &localCert->crt.subject);
+    mbedtls_ret = mbedtls_x509_crt_get_subject(&localCert->crt, &x509Name);
+    if (mbedtls_ret != 0)
+        return mbedtls_ret;
+
+    mbedtls_ret = mbedtls_x509_dn_gets(subject, sizeof(subject), x509Name);
     if (mbedtls_ret < 0) {
         return PAL_ERR_INVALID_X509_ATTR;
     }
@@ -2412,20 +2458,28 @@ palStatus_t pal_plat_x509CSRFromCertWriteDER(palX509Handle_t x509Cert, palx509CS
         return PAL_ERR_INVALID_X509_ATTR;
     }
 
+    mbedtls_ret = mbedtls_x509_crt_frame_acquire(&localCert->crt, &frame);
+    if (mbedtls_ret != 0)
+        return mbedtls_ret;
+
     // message digest alg
-    mbedtls_x509write_csr_set_md_alg(localCSR, localCert->crt.sig_md);
+    mbedtls_x509write_csr_set_md_alg(localCSR, frame->sig_md);
 
     // optional extensions
 
 #if !defined(MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3)
-    if (localCert->crt.version == 3)
+    if (frame->version == 3)
 #endif
     {
-        mbedtls_ret = copy_X509_v3_extensions_to_CSR((unsigned char *)localCert->crt.v3_ext.p, localCert->crt.v3_ext.len, localCSR);
+        mbedtls_ret = copy_X509_v3_extensions_to_CSR((unsigned char *)frame->v3_ext.p, frame->v3_ext.len, localCSR);
         if (mbedtls_ret != 0) {
+            mbedtls_x509_name_free(x509Name);
+            mbedtls_x509_crt_frame_release(&localCert->crt);
             return PAL_ERR_SET_EXTENSION_FAILED;
         }
     }
+    mbedtls_x509_name_free(x509Name);
+    mbedtls_x509_crt_frame_release(&localCert->crt);
 
     // write CSR
     return pal_plat_x509CSRWriteDER(x509CSR, derBuf, derBufLen, actualDerBufLen);
